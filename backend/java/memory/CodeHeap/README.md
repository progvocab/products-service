Great question 👍 — you’re asking about **CodeHeap areas** in the JVM, which is where **compiled native code (JIT-compiled methods)** is stored. This is part of the **HotSpot JVM’s CodeCache** (inside native memory, *not* Java heap).

When JIT compilation happens, methods get translated into machine code and stored in the **CodeCache**. Since Java 7/8, the CodeCache has been **segmented into different heaps** for better performance and management.

---

# 🔹 CodeHeap Segments

1. **CodeHeap ‘non-profiled nmethods’**

   * Stores **JIT-compiled methods** that were compiled *without profiling information*.
   * Usually **tier 2/3 compilation** (medium optimization, faster compilation, no detailed profiling).
   * Example: a method that’s hot enough to compile, but the JVM decides it doesn’t need deep profiling.

2. **CodeHeap ‘profiled nmethods’**

   * Stores **JIT-compiled methods with profiling info**.
   * These methods are first compiled at **C1 tier (client compiler)** with **profiling enabled** to gather runtime statistics (branch probabilities, type feedback, inline opportunities).
   * Profiling data is later used by the **C2 compiler (server compiler)** for highly optimized recompilation.
   * Acts as a staging ground → methods here may get recompiled into even more optimized forms.

3. **CodeHeap ‘non-nmethods’**

   * Stores **all other JIT-related code** that is **not actual Java methods**, such as:

     * JVM runtime stubs (e.g., adapters for calling between compiled/interpreted code).
     * Exception handling stubs.
     * Safepoint polling code.
     * Native code for inline caches, etc.
   * Basically, support code generated by the JIT for the JVM runtime.

---

# 🔹 Memory Layout of CodeCache

```mermaid
flowchart TD
    A[CodeCache (Native Memory)] --> B[CodeHeap 'non-profiled nmethods']
    A --> C[CodeHeap 'profiled nmethods']
    A --> D[CodeHeap 'non-nmethods']

    B -->|Stores| B1[JIT-compiled methods<br>without profiling]
    C -->|Stores| C1[JIT-compiled methods<br>with profiling info]
    D -->|Stores| D1[Runtime stubs<br>Exception stubs<br>IC stubs<br>etc.]
```

---

# 🔹 Why Segmentation?

* Before Java 7/8, all JIT code went into a single **CodeCache**.
* Problem: fragmentation + poor control → some areas filled quickly (e.g., stubs) while others had space.
* With segmentation:

  * JVM can control allocation for different kinds of code separately.
  * Prevents important runtime stubs from being blocked by tons of compiled methods.
  * Improves GC and flushing of unused methods.

---

# 🔑 Summary

| CodeHeap Type             | Stores                                                    | Purpose                                                                 |
| ------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------------- |
| **Profiled nmethods**     | JIT-compiled methods with profiling                       | Used for adaptive optimizations (C1 + profiling, then C2 recompilation) |
| **Non-profiled nmethods** | JIT-compiled methods without profiling                    | Quicker compilation, less optimized                                     |
| **Non-nmethods**          | Support code (stubs, runtime helpers, exception handlers) | Required for JVM internals                                              |

---

👉 Would you like me to also explain **how to monitor these CodeHeap areas at runtime** (e.g., with `jcmd` or JVM flags like `-XX:+PrintCodeCache`)?
